import{Q as k}from"./bootstrap-249b0f62.js";const y=k("market",{state:()=>({markets:[],futures:[],main_markets:[],main_markets_volume:[],favs:[],ecos:[],bestAsk:null,bestBid:null,exchange:null,futuresExchange:null,widget:null,market:null,future:null,currencyBalance:null,pairBalance:null,wallet_type:null,loading:!1,closePositionType:null,isShowModal:{closePositionMarket:!1,takeProfitStopLoss:!1}}),actions:{closeModal(e){this.isShowModal[e]=!1},showModal(e){this.isShowModal[e]=!0},async fetch_markets(){let e=localStorage.getItem("markets"),t=localStorage.getItem("marketsTimestamp"),a=new Date().getTime();if(e&&t&&a-t<=10*60*1e3){this.markets=JSON.parse(e);return}this.markets.length===0&&(this.markets=await axios.get("/data/markets/markets.json"),localStorage.setItem("markets",JSON.stringify(this.markets)),localStorage.setItem("marketsTimestamp",a.toString()))},async fetch_futures(){let e=localStorage.getItem("futures"),t=localStorage.getItem("futuresTimestamp"),a=new Date().getTime();if(e&&t&&a-t<=10*60*1e3){this.futures=JSON.parse(e);return}this.futures.length===0&&(this.futures=await axios.get("/data/markets/futures.json"),localStorage.setItem("futures",JSON.stringify(this.futures)),localStorage.setItem("futuresTimestamp",a.toString()))},spotMarketsData(e){let t={};for(const a of Object.values(e).filter(r=>r.spot))t||(t={}),t[a.quote]||(t[a.quote]={}),t[a.quote][a.symbol]=a;return t},futureMarketsData(e){let t={};for(const a of Object.values(e).filter(r=>r.swap))t||(t={}),t[a.quote]||(t[a.quote]={}),t[a.quote][a.symbol]=a;return t},async fetch_favs(){await axios.post("/user/watchlist/data").then(e=>{this.favs=e.favs.sort((t,a)=>t.currency.localeCompare(a.currency))})},async fetch_main_markets(){await axios.get("/user/eco/market/pair").then(e=>{this.main_markets=e.markets})},async fetch_main_markets_volume(){await axios.get("/user/eco/market/volume").then(e=>{this.main_markets_volume=e})},async fetch_ecos(){await axios.get("/user/eco/market/symbol").then(e=>{this.ecos=e})},async fetchWallet(e,t,a="spot"){let r=a==="futures"?"/user/futures/wallet/balance":"/user/fetch/wallet",l=null;a==="spot"?l=Number(tradingWallet)===1?"trading":"funding":l="futures",await axios.post(r,{type:l,symbol:e}).then(s=>{t==1?this.currencyBalance=s.balance:t==2&&(this.pairBalance=s.balance)})},async createWallet(e,t,a="spot"){this.loading=!0;let r=a==="futures"?"/user/futures/wallet/store":"/user/wallet/store",l=null;a==="spot"?l=Number(tradingWallet)===1?"trading":"funding":l="futures",await axios.post(r,{type:l,symbol:e}).then(s=>{this.fetchWallet(e,t),$toast[s.type](s.message)}).catch(s=>{$toast.error(s.response.data.message)}).finally(()=>{this.loading=!1})},async executeTrade(e,t,a,r,l,s,m=null,f=null,h=null){this.loading=!0;const o=t==="market",u=e==="BUY",n=m!==null;let g=n?"/user/futures/trade/store":"/user/trade/store",c=null;if(n?c="futures":c=Number(tradingWallet)===1?"trading":"funding",o&&(u?this.bestAsk:this.bestBid)>0||!o&&a>0)return axios.post(g,{amount:Number.parseFloat(r),price:o?u?Number.parseFloat(this.bestAsk):Number.parseFloat(this.bestBid):Number.parseFloat(a),symbol:l,currency:s,type:t,side:e,wallettype:c,leverage:m,id:f,size:h}).then(i=>{i.messages?i.message.forEach(d=>{$toast[i.type](d)}):$toast[i.type](i.message),n?this.fetchWallet(s,2,"futures"):(this.fetchWallet(l,1),this.fetchWallet(s,2))}).catch(i=>{console.log(i)}).finally(()=>{this.loading=!1});{const i=o?u?"No Market Price, Please Do Limit Order":"Please wait for orderbook to load":"Please set a valid price";$toast.error(i),this.loading=!1}}},persist:!0});export{y as u};
